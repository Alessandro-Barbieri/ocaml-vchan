<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="S.MEMORY.html">
<link rel="next" href="S.ENDPOINT.html">
<link rel="Up" href="S.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Endpoint" rel="Chapter" href="Endpoint.html">
<link title="Port" rel="Chapter" href="Port.html">
<link title="Xenstore" rel="Chapter" href="Xenstore.html">
<link title="Location" rel="Chapter" href="Location.html">
<link title="S" rel="Chapter" href="S.html">
<link title="In_memory" rel="Chapter" href="In_memory.html">
<link title="In_memory_events" rel="Chapter" href="In_memory_events.html">
<link title="Vchan_lwt_unix" rel="Chapter" href="Vchan_lwt_unix.html">
<link title="Events_lwt_unix" rel="Chapter" href="Events_lwt_unix.html">
<link title="Memory_lwt_unix" rel="Chapter" href="Memory_lwt_unix.html"><title>S.EVENTS</title>
</head>
<body>
<div class="navbar"><a class="pre" href="S.MEMORY.html" title="S.MEMORY">Previous</a>
&nbsp;<a class="up" href="S.html" title="S">Up</a>
&nbsp;<a class="post" href="S.ENDPOINT.html" title="S.ENDPOINT">Next</a>
</div>
<h1>Module type <a href="type_S.EVENTS.html">S.EVENTS</a></h1>

<pre><span class="keyword">module type</span> EVENTS = <code class="code">sig</code> <a href="S.EVENTS.html">..</a> <code class="code">end</code></pre><hr width="100%">

<pre><span id="TYPEport"><span class="keyword">type</span> <code class="type"></code>port</span> </pre>


<pre><span id="VALsexp_of_port"><span class="keyword">val</span> sexp_of_port</span> : <code class="type"><a href="S.EVENTS.html#TYPEport">port</a> -> Sexplib.Sexp.t</code></pre><div class="info ">
an identifier for a source of events. Ports are allocated by calls to
      <code class="code">listen</code>, then exchanged out-of-band (typically by xenstore) and
      finally calls to <code class="code">connect</code> creates a channel between the two domains.
      Events are send and received over these channels.<br>
</div>

<pre><span id="VALport_of_string"><span class="keyword">val</span> port_of_string</span> : <code class="type">string -> [ `Error of string | `Ok of <a href="S.EVENTS.html#TYPEport">port</a> ]</code></pre>
<pre><span id="VALstring_of_port"><span class="keyword">val</span> string_of_port</span> : <code class="type"><a href="S.EVENTS.html#TYPEport">port</a> -> string</code></pre>
<pre><span id="TYPEchannel"><span class="keyword">type</span> <code class="type"></code>channel</span> </pre>


<pre><span id="VALsexp_of_channel"><span class="keyword">val</span> sexp_of_channel</span> : <code class="type"><a href="S.EVENTS.html#TYPEchannel">channel</a> -> Sexplib.Sexp.t</code></pre><div class="info ">
a channel is the connection between two domains and is used to send
      and receive events.<br>
</div>

<pre><span id="TYPEevent"><span class="keyword">type</span> <code class="type"></code>event</span> </pre>


<pre><span id="VALsexp_of_event"><span class="keyword">val</span> sexp_of_event</span> : <code class="type"><a href="S.EVENTS.html#TYPEevent">event</a> -> Sexplib.Sexp.t</code></pre><div class="info ">
an event notification received from a remote domain. Events contain no
      data and may be coalesced. Domains which are blocked will be woken up
      by an event.<br>
</div>

<pre><span id="VALinitial"><span class="keyword">val</span> initial</span> : <code class="type"><a href="S.EVENTS.html#TYPEevent">event</a></code></pre><div class="info ">
represents an event which 'fired' when the program started<br>
</div>

<pre><span id="VALrecv"><span class="keyword">val</span> recv</span> : <code class="type"><a href="S.EVENTS.html#TYPEchannel">channel</a> -> <a href="S.EVENTS.html#TYPEevent">event</a> -> <a href="S.EVENTS.html#TYPEevent">event</a> Lwt.t</code></pre><div class="info ">
<code class="code">recv channel event</code> blocks until the system receives an event
      newer than <code class="code">event</code> on channel <code class="code">channel</code>. If an event is received
      while we aren't looking then this will be remembered and the
      next call to <code class="code">after</code> will immediately unblock. If the system
      is suspended and then resumed, all event channel bindings are invalidated
      and this function will fail with Generation.Invalid<br>
</div>

<pre><span id="VALsend"><span class="keyword">val</span> send</span> : <code class="type"><a href="S.EVENTS.html#TYPEchannel">channel</a> -> unit</code></pre><div class="info ">
<code class="code">send channel</code> sends an event along <code class="code">channel</code>, to another domain
      which will be woken up<br>
</div>

<pre><span id="VALlisten"><span class="keyword">val</span> listen</span> : <code class="type">int -> <a href="S.EVENTS.html#TYPEport">port</a> * <a href="S.EVENTS.html#TYPEchannel">channel</a></code></pre><div class="info ">
<code class="code">listen domid</code> allocates a fresh port and event channel. The port
      may be supplied to <code class="code">connect</code><br>
</div>

<pre><span id="VALconnect"><span class="keyword">val</span> connect</span> : <code class="type">int -> <a href="S.EVENTS.html#TYPEport">port</a> -> <a href="S.EVENTS.html#TYPEchannel">channel</a></code></pre><div class="info ">
<code class="code">connect domid port</code> connects an event channel to <code class="code">port</code> on <code class="code">domid</code><br>
</div>

<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type"><a href="S.EVENTS.html#TYPEchannel">channel</a> -> unit</code></pre><div class="info ">
<code class="code">close channel</code> closes this side of an event channel<br>
</div>
</body></html>